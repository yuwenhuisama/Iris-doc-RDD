

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Iris对象模型介绍 &mdash; Iris  文档</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="prev" title="Iris语言语法介绍" href="../syntex/syntex-index.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Iris
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../syntex/syntex-index.html">Iris语言语法介绍</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Iris对象模型介绍</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">导语</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">1、术语定义</a></li>
<li class="toctree-l2"><a class="reference internal" href="#everything-is-object">2、Everything is Object</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">3、对象之间的关系</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#is-a-instance-of">3.1、is-a/instance-of关系</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#irisis-a-instance-of">注：Iris中的特殊is-a/instance-of关系</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">2、组合关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">3、继承关系</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id7">注：Iris中的特殊继承关系</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mix-in">4、mix-in关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="#joint">5、joint关系</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">4、对象和方法的关系</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">1、实例方法和类方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">2、 实例方法的存储与查找</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">补充：类方法的查找顺序</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id12">5、实例变量和类变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">6、语言扩展</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Iris</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Iris对象模型介绍</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/oop-patern/oop-patern.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="iris">
<h1>Iris对象模型介绍<a class="headerlink" href="#iris" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>导语<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<blockquote>
<div>本文档用于介绍Iris语言面向对象模型的具体概念，以及在具体实现上的建议实现方法。</div></blockquote>
</div>
<div class="section" id="id2">
<h2>1、术语定义<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><strong>Host Side</strong>：特指用于实现Iris语言的解释器/虚拟机的语言方（如C++/Java/Javascript等）；</li>
<li><strong>Appear Side</strong>：特指Iris脚本语言的文本、所要执行的内容等；</li>
<li><strong>Iris Core</strong>：特指用于执行Iris脚本的核心构件，在用面向对象的描述方式下，包括且不仅包括（依据具体实现而定）<em>IrisObject、IrisClass、IrisModule、IrisInterface、IrisMethod、IrisClosureBlock</em>这六个类；</li>
<li><strong>Extend Class/Module</strong>：特指在<em>Host Side</em>编写的、可以在Iris中使用的类/模块；</li>
<li><strong>User Class/Module</strong>：是Extend Class的一类，指的是第三方用于在Host Side编写的、用于扩展Iris的类/模块；</li>
<li><strong>Iris Bytecode</strong>：指为Iris语言设计的虚拟机字节码</li>
<li><strong>Interpreter</strong>：指用于解释并执行Iris Bytecode的解释器以及相关的构件比如<em>GC模块</em>等（视具体实现而定），有时<em>Interpreter</em>也用<em>Virtual Machine</em>代称；</li>
</ul>
<blockquote>
<div>注1：在本文档对于Iris对象模型的实现的描述上，约定均以面向对象的观点来进行描述；注2：为避免混淆，下文中凡是以<em>Iris</em>作为前缀的类名都是指在<em>Host Side</em>实现的类，其它的均为在<em>Appear Side</em>实现的类。</div></blockquote>
</div>
<div class="section" id="everything-is-object">
<h2>2、Everything is Object<a class="headerlink" href="#everything-is-object" title="永久链接至标题">¶</a></h2>
<p>在Iris中，一切语言组件都被视为对象。Iris的字面语言组件有以下几类：</p>
<blockquote>
<div><ol class="simple">
<li>对象（Object）</li>
<li>类（Class）</li>
<li>模块（Module）</li>
<li>接口（Interface）</li>
<li>方法（Method）</li>
<li>块（Block）</li>
</ol>
</div></blockquote>
<p>其中<em>对象</em>即为字面意义上的对象，它在<em>Host Side</em>均以<em>IrisObject</em>的形式表示，而剩下的<em>类、模块、接口、方法、块</em>在<em>Host Side</em>分别以<em>IrisClass、IrisModule、IrisInterface、IrisMethod、IrisClosureBlock</em>来表示。然而在<em>Appear Side</em>，所有的这些组件均视为某各类的对象——具体而言，也就是说__任何一个Class、Module、Interface、Method、Block都分别是Iris语言中<em>Class、Module、Interface、Method、Block</em>类的一个对象。__</p>
<p>以Class类为例，考察如下Iris代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="n">fun</span> <span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">do</span> <span class="n">something</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">;</span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="p">;</span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>在上面的代码中我们定义了一个类名字叫MyClass、它包含一个实例方法foo，然后生成了一个<em>MyClass</em>类的对象，并调用实例方法<em>foo</em>。这是一个比较浅显的观点，而具体而微地站在Iris面向对象模型上来看，实际上这段代码做了这样一些事情：</p>
<blockquote>
<div><ol class="simple">
<li>生成一个<em>Class类</em>的对象，__ 并将这个对象赋值给常量<em>MyClass</em>__；</li>
<li>生成一个<em>Method类</em>的对象，并将这个对象注册给<em>MyClass</em>常量所保存的那个<em>Class</em>对象以作为一个<strong>实例方法</strong>，并且<em>MyClass</em>中的那个类对象的实例能够通过<em>foo</em>来访问到这个方法；</li>
<li><strong><em>MyClass</em>中的那个类对象调用了它自己的实例方法<em>new</em></strong>（<strong>这个实例方法定义在 <em>Class</em>类中</strong>），生成了一个新的对象，并保存在变量<em>obj</em>中；</li>
<li><em>obj</em>对象通过<em>foo</em>查找到自己的实例方法<em>foo</em>；</li>
<li><em>foo</em>方法调用自己的实例方法<em>call</em>（<strong>定义在 <em>Method</em>类中</strong>）；</li>
</ol>
</div></blockquote>
<p>也就是说，去掉语法糖衣，真实的代码类似于下面这样：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>;MyClass = Class.new()
;foo = Method.new() {
    iterator =&gt; [bar] :
    // do something
 } // 这里用到了Iris元编程的内容，看不懂可以不管
;MyClass.add_instance_method(foo)
;obj = MyClass.new()
;foo_mtd = obj.get_instance_method(&quot;foo&quot;)
;foo_mtd.call(obj, nil)
</pre></div>
</div>
<blockquote>
<div><p>注1: 顺便一提，从这里可以看出对于Iris而言，<em>class语句、fun语句</em>都算是语法糖衣，我们完全可以通过<strong>元编程</strong>的方法完成一切类、方法的定义等操作。</p>
<p>注2：对于<code class="docutils literal notranslate"><span class="pre">foo_mthd.call(obj,</span> <span class="pre">nil)</span></code>这一段代码，显然存在一个疑问，按照这个推理下去，应该是<em>foo_mthd</em>继续去查找<em>call</em>方法，然后找到<em>call</em>方法对应的那个<em>Method</em>对象，然后这个对象再去调用<em>call</em>……这样下去就出现了一个<em>反复查找-调用</em>的死循环。在逻辑上这个问题确实是讲得通的，因此在Iris的脚本书写中，调用方法直接使用 <em>method_name()</em> 的形式，其实是用这个小trick屏蔽了这样一个无限循环的怪圈，至于实际实现上其实并不存在这样一个问题，具体的原因在于任何<em>Appear Side</em>的方法调用最终都会转换到<em>Host Side</em>的方法调用（比如用C++实现那么最终调用的是一个C++函数，用Java实现最终调用的是一个MethodHandle），具体见后文。</p>
</div></blockquote>
<p>因此，要实现Iris的面向对象模型，首先要明白在Iris中<strong>对象是一等公民</strong>，一切的实现都应该围绕着对象实现。因此在<em>Host Side</em>，建议进行这样子的实现：</p>
<blockquote>
<div><ol class="simple">
<li>实现名为<em>IrisObject</em>的类，它代表了Iris中所有的对象在<em>Host Side</em>的表现形式：即__任何一个Iris对象都对应一个<em>IrisObject</em>对象__；</li>
<li>分别为其它字面对象实现<em>IrisClass、IrisModule、IrisInterface、IrisMethod、IrisClosureBlock</em>类，<strong>对于类、模块、接口、方法以及块的Iris对象，除了对应IrisObject类以外，还应该分别是上述五个类的一个对象</strong>；</li>
<li>在2的基础上，每个<em>IrisClass、IrisModule、IrisInterface、IrisMethod、IrisClosureBlock</em>类的对象应该有一个字段名为 <em>(class/module/interface/method/closureBlock)Object</em>，用于保存该对象实际对应的<em>IrisObject</em>对象。</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="id3">
<h2>3、对象之间的关系<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>由上可以看出，Iris语言是由对象构成的一个庞大体系，因此对象和对象之间自然存在各种各样的关系，总结出来有如下5种：</p>
<blockquote>
<div><ol class="simple">
<li>is-a/instance-of关系</li>
<li>组合关系</li>
<li>继承关系</li>
<li>mix-in关系</li>
<li>joint关系</li>
</ol>
</div></blockquote>
<div class="section" id="is-a-instance-of">
<h3>3.1、is-a/instance-of关系<a class="headerlink" href="#is-a-instance-of" title="永久链接至标题">¶</a></h3>
<p>is-a或者说instance-of是普通对象与类对象的关系，对于表达式</p>
<blockquote>
<div>a is-a B</div></blockquote>
<p>或者</p>
<blockquote>
<div>a instance_of B</div></blockquote>
<p>而言，表示的是对象a是否为类B的一个对象，如果是，返回<em>true</em>，否则返回<em>false</em>。其次，这里的判断进一步包含了这样一层意思：</p>
<blockquote>
<div><p>若类C为类B的父类，那么表达式</p>
<blockquote>
<div>a is-a B</div></blockquote>
<p>或者</p>
<blockquote>
<div>a instance-of B</div></blockquote>
<p>的结果，与表达式</p>
<blockquote>
<div>a is-a C</div></blockquote>
<p>或者</p>
<blockquote>
<div>a instance-of C</div></blockquote>
<p>的结果相同，但反之则不然。</p>
</div></blockquote>
<div class="section" id="irisis-a-instance-of">
<h4>注：Iris中的特殊is-a/instance-of关系<a class="headerlink" href="#irisis-a-instance-of" title="永久链接至标题">¶</a></h4>
<div class="section" id="nil-false-true">
<h5>1. <em>nil/false/true</em>对象<a class="headerlink" href="#nil-false-true" title="永久链接至标题">¶</a></h5>
<p>在Iris中<em>nil/false/true</em>关键字分别表示<strong>空/假/真</strong>值，它们分别是<em>NilClass/FalseClass/TrueClass</em>类的对象且全局仅允许存在这么一个<em>NilClass/FlaseClass/TrueClass</em>对象，<strong>也即是说<em>NilClass/FlaseClass/TrueClass</em>禁止再生成新的对象。</strong></p>
</div>
<div class="section" id="id4">
<h5>2. 类对象<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h5>
<p>Iris中任何一个类都是<em>Class</em>类的对象，这一点在上面已经讨论过了，那么<em>Class</em>类这个对象是哪个类的对象呢？</p>
<p>答案是<em>Class</em>类本身就是<em>Class</em>类的对象。听起来似乎有些天方夜谭，但按照Iris的面向对象模型而言，确实如此。事实上<em>Class</em>类虽然是一个类，但是由于在Iris中对象是一等公民，所以<em>Class</em>类同时也就是一个对象，而它自己（站在对象的角度上来看）确实就是自己的对象（站在类的角度上来看）了。</p>
<p>也即是说以下表达式成立：</p>
<blockquote>
<div>Class is-a Class 或者 Class instance-of Class</div></blockquote>
</div>
<div class="section" id="object">
<h5>3. <em>Object</em>对象<a class="headerlink" href="#object" title="永久链接至标题">¶</a></h5>
<p>Iris中<em>Object</em>类是所有类的父类，Iris中的任何一个对象都是<em>Object</em>类的对象也即是说<strong>对于任何对象obj，以下表达式成立</strong></p>
<blockquote>
<div>obj is-a <em>Object</em> 或者 obj instance-of <em>Object</em></div></blockquote>
<p>同时由于<em>Object</em>是一个类，因此以下表达式也成立：</p>
<blockquote>
<div><em>Object</em> is-a <em>Class</em> 或者 <em>Object</em> instance-of <em>Class</em></div></blockquote>
<p>当然，更进一步的，还有下面的表达式成立：</p>
<blockquote>
<div><em>Class</em> is-a <em>Object</em> 或者 <em>Class</em> instance-of <em>Object</em><em>Object</em> is-a <em>Object</em> 或者 <em>Object</em> instance-of <em>Object</em></div></blockquote>
</div>
</div>
</div>
<div class="section" id="id5">
<h3>2、组合关系<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>组合关系即对象a为对象b的一个成员，在Iris中以实例变量的形式体现。</p>
</div>
<div class="section" id="id6">
<h3>3、继承关系<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>继承关系是类对象与类对象之间的关系，在Iris中若类A继承类B或为B的间接子类，则有以下特征：</p>
<blockquote>
<div><ol class="simple">
<li>在类B中定义的实例方法m，类A的实例obj按以下规则访问：<ol>
<li>若m的访问权限为everyone，那么obj可在任何情况下访问调用m；</li>
<li>若m的访问权限为relative，那么obj仅能在其可访问的方法内部访问调用m；</li>
<li>若m的访问权限为personal，那么obj无法访问调用m；</li>
</ol>
</li>
<li>任何一个类A的对象都是类B的对象，反之则不然；</li>
<li>在类A中删除任何一个类B中继承过来的实例方法，对于类B没有任何影响；</li>
<li>在类A中改变任何一个类B中继承过来的实例方法的访问权限，对于类B没有任何影响；</li>
<li>在类B中没有任何方法可以隐式访问类A的类方法，只能显式访问。</li>
</ol>
</div></blockquote>
<div class="section" id="id7">
<h4>注：Iris中的特殊继承关系<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><ol class="simple">
<li>Class类的父类是Object类，而Object类对象是Class类的一个对象；</li>
<li>Object类的父类是Object类，而Object类对象是一个Class类实例；</li>
<li>任何一个在定义时没有显示指明父类的类的父类都是Object类。</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="mix-in">
<h3>4、mix-in关系<a class="headerlink" href="#mix-in" title="永久链接至标题">¶</a></h3>
<p>mix-in关系是类对象与模块对象之间的关系。在Iris中模块被看做是方法的集合，用于弥补Iris单继承存在的某些问题。</p>
<p>若类A与模块B有mix-in关系，那么存在以下特征：</p>
<blockquote>
<div><ol class="simple">
<li>在模块B中定义的所有实例方法都作为类A中定义的实例方法看待，包括其访问权限；</li>
<li>在类A中删除模块B中存在的实例方法对模块B没有任何影响；</li>
<li>在类A中修改模块B中存在的实例方法的访问权限对模块B没有任何影响；</li>
<li>在类A中没有任何方法可以隐式访问模块B的类方法，只能显示访问。</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="joint">
<h3>5、joint关系<a class="headerlink" href="#joint" title="永久链接至标题">¶</a></h3>
<p>joint关系是类对象与接口对象之间的关系，joint关系主要用于实现一些约定，即功能提供方对功能使用方的一些约束。</p>
<p>若类A与接口B有joint关系，那么存在以下特征：</p>
<blockquote>
<div><ol class="simple">
<li>类A必须实现接口B中定义要实现的所有实例方法，并且需要保证方法名、方法参数个数以及是否有可变参数一一对应；</li>
<li>如果存在未对应的情况，那么Iris主动抛出异常。</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="id8">
<h2>4、对象和方法的关系<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<div class="section" id="id9">
<h3>1、实例方法和类方法<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>在Iris语法上来看存在两类方法：实例方法和类方法。其中实例方法是一个类的对象可以调用的方法，而类方法则是类本身可以调用的方法。然而在这里所谓的实例方法和类方法仅仅是一个语法糖衣，对于Iris对象模型而言，只存在实例方法而没有类方法。</p>
<p>那么类方法到哪儿去了呢？类方法事实上就是类对象的实例方法。</p>
<p>考察以下代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="n">fun</span> <span class="n">instance_method</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">do</span> <span class="n">something</span>
    <span class="p">}</span>
    
    <span class="n">fun</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_method</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">do</span> <span class="n">something</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">;</span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
<span class="p">;</span><span class="n">obj</span><span class="o">.</span><span class="n">instance_method</span><span class="p">()</span>
<span class="p">;</span><span class="n">MyClass</span><span class="o">.</span><span class="n">class_method</span><span class="p">()</span>
</pre></div>
</div>
<p>这里为<em>MyClass</em>定义了实例方法<em>instance_method</em>和类方法<em>class_method</em>，<em>MyClass</em>调用了自己的类方法<em>new</em>和<em>class_method</em>，<em>MyClass</em>的实例调用了它的实例方法<em>instance_method</em>。而事实上定义<em>class_method</em>的时候是把<em>class_method</em>注册成了<em>MyClass</em>常量所保存的那个类对象的实例方法，因此事实上<code class="docutils literal notranslate"><span class="pre">MyClass.class_method()</span></code>这段代码__仍旧是一个对象调用实例方法的过程。__</p>
<p>同理，对于模块而言，模块也可以调用它定义的类方法，但事实上用模块调用类方法的过程依旧如上。</p>
<p>因此，在实现上，建议<em>IrisClass/IrisModule</em>的<em>RegistClassMethod(method)</em> 方法都转为将<em>method</em>注册到<em>IrisClass/IrisModule</em>的 <em>(class/module)Object</em>的实例方法上。</p>
<p>而在调用方法的时候，就统一用对象去调用实例方法就行了，免去了区分类方法和实例方法的麻烦。</p>
</div>
<div class="section" id="id10">
<h3>2、 实例方法的存储与查找<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>在Iris中，任何方法都是<em>Method</em>类的一个对象，按照前面的建议，这个对象在<em>Host Side</em>保存在<em>methodObject</em>中，而真正和<em>Host Side</em>挂上关系的其实是<em>IrisMethod</em>这个类，保存到<em>IrisClass、IrisModule</em>中的，也是<em>IrisMethod</em>对象。</p>
<p>对于存储方式，建议使用<em>key-value</em>的方式，在<em>IrisObject</em>中使用一个类似<em>HashMap</em>的结构进行存储，比如在类中定义了一个名为<em>foo</em>的实例方法，那么就在这个<em>HashMap</em>中按照 <em>“foo”=&gt; object</em>的形式进行保存，查找的时候直接使用 *”foo”*查找即可。</p>
<blockquote>
<div><p>注：Iris每一个对象都可以拥有自己的实例方法，考虑以下代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class MyClass {
    fun foo() {
        // do something
    }
}
;a = MyClass.new()
;b = MyClass.new()
;class &gt;&gt; b {
    fun foo2() {
        // do something
    }
 }
;a.foo()
;b.foo()
;b.foo2()
;a.foo2() // Error
</pre></div>
</div>
<p>这里单独为实例b定义了<em>foo2</em>方法，而虽然a、b同属于一个类<em>MyClass</em>，但是a则没有<em>foo2</em>方法可以调用。</p>
</div></blockquote>
<p>对于一个实例方法的调用：</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">;obj.foo()</span></code></div></blockquote>
<p>Iris将会按照以下顺序进行查找：</p>
<blockquote>
<div><ol class="simple">
<li>查找obj自己的实例方法，如果有调用之，否则进入2；</li>
<li>在obj的类中查找实例方法，如果有调用之，否则进入3；</li>
<li>在和obj有mix-in关系的模块中查找实例方法，如果有调用之，否则进入4；</li>
<li>在obj的父类、间接父类中按照2和3的顺序进行查找，如果有调用之，否则进入5；</li>
<li>查找到Object类如果还是没有查找到，那么Iris主动调用obj.missing_method()方法。</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="id11">
<h3>补充：类方法的查找顺序<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>Iris中任何类都是<em>Class</em>类的对象，这里以<em>new</em>方法为例进行一个介绍：</p>
<p>考虑代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{}</span>
<span class="p">;</span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
</pre></div>
</div>
<p>当要调用<em>new</em>方法的时候，Iris做以下工作：</p>
<blockquote>
<div><ol class="simple">
<li>在<em>MyClass</em>对应的<em>IrisObject</em>中查找是否有名为<em>new</em>的实例方法，如果有，调用之，否则进入2；</li>
<li><em>MyClass</em>是<em>Class</em>类的一个实例，因此Iris进入<em>Class</em>类定义的实例方法中进行查找，此时查找到有该方法存在，调用之。</li>
</ol>
</div></blockquote>
<p>此时把<em>MyClass</em>换成<em>Class</em>，那么对于<code class="docutils literal notranslate"><span class="pre">;Class.new()</span></code>的调用过程和上述完全一致。</p>
<p>进一步的，由于Iris中任何类都是<em>Object</em>类的子类，因此如果<em>MyClass</em>想要调用<em>Object</em>类的方法比如<em>to_string</em>，那么<em>MyClass</em>不会在<em>Class</em>类中查找到该方法，进而转到<em>Class</em>类的父类<em>Object</em>中查找到该方法然后调用之。</p>
<p>我们总结一下，关于类对象可以调用的方法如下：</p>
<blockquote>
<div><ol class="simple">
<li>类对象自己的实例方法（也即类中定义的类方法）；</li>
<li><em>Class</em>类的中定义的实例方法；</li>
<li><em>Object</em>类中定义的实例方法。</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="id12">
<h2>5、实例变量和类变量<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>在Iris中以&#64;开头的变量为实例变量，以&#64;&#64;开头的变量为类变量。</p>
<p>实例变量，顾名思义，即是一个实例单独享有的变量，不和本类的其他实例共享；而类变量则是类（或者模块）拥有的变量，所有的类的实例都共享同一个类变量。此外，所有子类以及间接子类中都享有父类（或者父类的模块）中出现的类变量。</p>
<p>类变量是一种特殊的变量，本质上来讲它是一个语法糖衣，严格来讲并不属于Iris对象模型的任何一个方面，Iris提供类变量仅仅是出于方便的考虑，事实上类变量与Iris对象模型是格格不入的。</p>
<p>在实现上建议每个<em>IrisObject</em>对象都拥有一个类似于<em>HashMap</em>的结构用于能够以<em>key-value</em>的形式保存实例变量的名字和相应的值。</p>
<p>而类变量仅能够存在于<em>IrisClass和IrisModule</em>中，也建议以<em>key-value</em>的形式保存。</p>
</div>
<div class="section" id="id13">
<h2>6、语言扩展<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<p>Iris所拥有的功能在于附加于其上的扩展，一般在<em>Host Side</em>进行扩展，而对于Iris而言，可以扩展的有<em>类、模块以及接口</em>。</p>
<p>扩展的编写是将<em>Host Side</em>连接到<em>Appear Side</em>的过程，比如如果要为Iris扩展一个类，那么就需要在<em>Host Side</em>先编写相应的类功能，然后再连接到<em>Appear Side</em>，使得<em>Appear Side</em>能够展现<em>Host Side</em>的功能。</p>
<p>一种可行的同时也是建议的实现方式是通过<em>Native Object</em>的形式进行绑定扩展。这里的<em>Native Object</em>指的是<em>Host Side</em>的<em>Object</em>。比如如果要在<em>Appear Side</em>生成一个<em>String</em>，那么相应的就需要在<em>Host Side</em>生成一个<em>Native String</em>（在C++上可能以stl::string展示而在Java上可能以String展示），然后将<em>Host Side</em>的对象绑定到<em>Appear Side</em>上，更具体地来说，就是将<em>Host Side</em>的对象绑定到<em>IrisObject</em>上，为此需要在<em>IrisObject</em>中添加一个<em>nativeObject</em>字段，用于存储这个<em>Host Side</em>的Object。（在C++上可能使用<em>void*<em>在Java上可能使用</em>Object</em>）。</p>
<p>更进一步的，完成了<em>Host Side</em>到<em>Appear Side</em>的对象绑定之后，还需要完成方法的注册（绑定）。至于方法的注册，一种可行且建议的方法是让<em>IrisMethod</em>去保存__在<em>Host Side</em>用以表示一个函数或者方法的数据结构__，比如在C++中是函数指针而在Java中是MethodHandle，它拥有类似的签名：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IrisValue</span> <span class="n">MethodName</span><span class="p">(</span><span class="n">IrisValue</span> <span class="bp">self</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">IrisValue</span><span class="o">&gt;</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">IrisValue</span><span class="o">&gt;</span> <span class="n">variableParameters</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>其中<em>self</em>表示调用者，<em>parameters</em>表示传进来的固定参数，<em>variableParameters</em>表示传进来的可变参数。</p>
<blockquote>
<div>注：这里的<em>IrisValue</em>表示在<em>Host Side</em>用于保存<em>IrisObject</em>的数据结构，为了数据交换方便一般不直接使用<em>IrisObject</em>。</div></blockquote>
<p>当完成了这样子的<em>类似函数或者方法的数据结构</em>，就可以将它保存到一个新的<em>IrisMethod</em>中，为此<em>IrisMethod</em>应该有一个字段用来保存这个数据结构。</p>
<blockquote>
<div>注：在Iris中应该存在两类方法，一类是按照上面的说明直接在<em>Host Side</em>定义出来的<em>Native Method</em>，而另外一类，则是在<em>Appear Side</em>即在脚本代码中定义的<em>User Method</em>（用<em>fun</em>语句）。因此调用的时候，应该区分进行。但是可以确定的是，一个方法的最终调用都会归为<em>Native Method</em>的调用。</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../syntex/syntex-index.html" class="btn btn-neutral" title="Iris语言语法介绍" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Hui.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>